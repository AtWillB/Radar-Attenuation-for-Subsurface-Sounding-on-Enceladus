# depth_map_util.py was written by William Byrne in the Fall of 2023
# To be used by DLR - Institute of Planetary Research
# Script used to calcualte attenuation from the temperature feild in on time series instance in a GAIA simulation (one PX_OUT file)

import radar_attenuation.attenuation_calculator as ac
from gaia import Simulation

import numpy as np
import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt




def load_sim(caseID, path_to_case_id, time_index = -1):
    """
    load_sim takes a caseID(ID for GAIA simulation files) and a path_to_case_id and loads a Simulaiton class object from the GAIA grid and PX_OUT files
    load_sim returns a simulation object alone unless a time index is specified, in which case it will return both a Simulation class instance and a Output class insance
    At defulat, the Output(o) class instance will be the last PX_OUT file in the simulation in chronological order(simulation @ current day)
    Print information about the simulation loaded, and the time loaded if one is selected

    param caseID: ID(as a string) of the simulation to be loaded
    param path_to_case_id: path to the .grid and PX_OUT files
    param time_index: specific time(as an integer) index to be loaded from all the PX_OUT files. Defaults to -1(Last simulation in chronological order)
    return: a tuple conatining either the simulation class instance alone, or both the simulation  and specicif output class instance for a given time index
    """

    s = Simulation(caseid=caseID, sim_dir=f"{path_to_case_id}", grid_dir=f"{path_to_case_id}")
    return_list = (s)

    print("Case: " + s.caseid + " Loaded Grid: " + s.grid.gridfile)
    print("Got " + str(s.update()) + " new files, " + str(len(s.files))+ " in total.")

    if time_index:
        times = s.getTimes()

        o = s.getAtTime(times[time_index])
        print("Loaded time " + str(o.time) + " and iteration " + str(s.time_iter[o.time]))
        return_list = (s, o)

    pps=str(s.grid.nCells/s.grid.nShells)
    print("cells per depth " + pps)
    
    return return_list


def calc_angular_ratio_data(big_df_list, simulation_model_type, a_r = 15):
    """
    calc_angular_ratio_data reformats a list of attenuation calculations as DataFrames to be used in a angular ratio plot

    param big_df_list: list of DataFrames generated by calc_gaia_attenuation to be placed in one angular ratio plot
    return: a large DataFrame showing showing the spacial distribution of attenuation calculations from the bottom of the individual Output class instance to the top 
    """
    big_df = pd.concat(big_df_list)

    big_df['column'] = big_df['column'].str.replace("column_", "")
    big_df['column'] = big_df['column'].astype(int)
    big_df.set_index("column")
    model_name_list = list(big_df["simulation_model"].unique())

    depthwise_plot = []    
    for model_name in model_name_list:

        small_df = big_df.query(f'simulation_model == @model_name').copy(deep = True)
        max_depth = small_df['depth'].max()

        num_col = len(small_df['column'].unique())
        small_df['a_r'] = small_df['column'] * (a_r)/num_col
        small_df = small_df.query("twoway_loss >= 60 and twoway_loss <= 100").groupby(['simulation_model','a_r'])['depth'].max().reset_index()
        small_df['depth'] = (small_df['depth']/max_depth)*100

        depthwise_plot.append(small_df)

    depthwise_plot = pd.concat(depthwise_plot)
    depthwise_plot.rename({'simulation_model':simulation_model_type}, axis = 'columns', inplace = True)

    return depthwise_plot


def calc_gaia_attenuation(gaia_temp_table, R0, nShells, nCellsPerShell, attenuation_model, simulation_model, savepath = False):
    """
    calc_gaia_attenuation calculates attenuation for a given slice of a GAIA simualtion time series and places them in a Pandas DataFrame.

    param gaia_temp_table: 
    param R0: Radius (in meters) of planet you are simulating
    param nShells: number of shells in the Ouput class instance to have attenuation calculations applied
    param nCellsPerShell: number of shells per shell in the Ouput class instance to have attenuation calculations applied
    param attenuation_model: attenuation_model to be used for attenuation calculation. either ["low_loss", "mid_loss", or "high_loss"]
    param simulation_model: the variable unique to this simulation (Grain Size). Used to differencitat between other simulations
    pram savepath: If savepath is not false, save the resulting DataFrame as a csv with the following savepath. This includes the files name (exp. ../data/filename.csv)
    return: a DataFrame containing attenuation calculations for a given slice of a GAIA simulation time series, and a numpy array to be used by mk_gaia_attenuation_plot specifically for visualization
    """

    x = gaia_temp_table[:, 0]*1000
    y = gaia_temp_table[:, 1]*1000

    big_depth_array = (R0 - np.sqrt(x**2 + y**2))
    big_temp_array = gaia_temp_table[:, 3]

    big_depth_array = big_depth_array.reshape([nShells,  nCellsPerShell])
    big_temp_array = big_temp_array.reshape([nShells, nCellsPerShell])

    count  = 0
    df_list = []
    twoway_loss_list = []

    for small_depth_array, small_temp_array in zip(big_depth_array.T, big_temp_array.T):

        layers_dict = ac.calc_twoway_attenuation(small_depth_array, small_temp_array, attenuation_model)
        df = ac.dict_to_df(layers_dict)

        df['twoway_loss'] = df['twoway_loss'].astype(float)
        df['twoway_loss'] = round(df['twoway_loss'], 200)

        df = df.reset_index().rename(columns = {"index":"layer"})
        df['column'] = [f"column_{count}" for x in range(0, len(df['twoway_loss']))]
        df.set_index("column")
        twoway_loss_list.append(df['twoway_loss'].values)

        df_list.append(df)
        count += 1
        
    big_df = pd.concat(df_list)
    big_df.set_index("column")
    
    if savepath:
        to_save_df = big_df.copy(deep=True)

        to_save_df.rename(columns = {"depth": "depth_[m]", "thickness":"thickness_[km]", "temp" : "temp_[k]", "twoway_loss":"twoway_loss_[db]"}, inplace = True)
        to_save_df.to_csv(f"{savepath}")


    big_attenuation_list = np.array(twoway_loss_list)
    big_df['simulation_model'] = simulation_model

    return big_df, np.flipud(big_attenuation_list.T)


def mk_gaia_attenuation_plot(o, graph_array, title, upperlim, fig, ax, fontsize, cbar_ax = [1,1,1,1], lowerlim = 0, residual = False):
    """
    mk_gaia_attenuation_plot plots the attenuation of one time slice of a GAIA simulation

    param o: Output class instance from Simulation class instance of simulation
    param graph_array: DataFrame created from calc_gaia_attenuation
    param title: title of cbar
    param upperlim: upper limit of attenuation to be displayed by colormap
    param fig: Figure instance created from plt.subplots() call
    param ax: Axes instance created from plt.subplots() call
    param fontsize: fontsize of colorbar title
    param cbar_ax: Where to place the attenuation plot colorbar on the MatPlotLib Figure in refrence to the Axes this plot is drawn on. Defaults to [1,1,1,1]
    param lowerlim: lower limit of attenuation to be displayed by colormap
    param residual: whether or not to show mean residual attenuation plot instead of exact attenuation plot

    return: a colorbar instance for this plot
    """


    x=o.grid.coords[:,0].reshape([o.grid.nShells, o.grid.nCellsPerShell[0]])
    y=o.grid.coords[:,1].reshape([o.grid.nShells, o.grid.nCellsPerShell[0]])

    if residual == True:
        count = 0
        for idx, val in np.ndenumerate(graph_array):
            graph_array[idx[0], idx[1]] =  (graph_array[idx[0], :].mean() - graph_array[idx[0], idx[1]])/graph_array[idx[0], :].mean()

        upperlim = 5
        lowerlim = -5

    T = graph_array
    cmap = sns.color_palette("rocket", as_cmap = True)


    conjtourplot = ax.contourf(x, y, T, np.linspace(lowerlim, upperlim,256), cmap=cmap, extend="both")
    ticksstep = upperlim/4
    cbarticks = np.arange(T.min() - (T.min()%ticksstep), T.max() - (T.max()%ticksstep) + ticksstep, ticksstep)
    cbarticks = np.arange(lowerlim, upperlim+ticksstep, ticksstep)
    cbar_ax = fig.add_axes(cbar_ax)
    cb = fig.colorbar(conjtourplot, orientation="horizontal", pad=0.02, shrink=0.8, ticks=cbarticks, cax = cbar_ax)
    cb.set_label(label=title, fontsize=fontsize) #22 # 28
    plt.setp(cb.ax.xaxis.get_ticklabels(), fontsize=fontsize - 1.5) #20 # 26
    ax.axis('off')

    return cb


def mk_gaia_T_plot(o, scaleT, T0, upperlim, fig, ax, fontsize, cbar_ax = [1,1,1,1], lowerlim = 0):
    """
    mk_gaia_T_plot plots the temperature of one time slice of a GAIA simulation

    param o: Output class instance from Simulation class instance of simulation
    param scaleT: value used to redimensionalize the GAIA temperature field
    param upperlim: upper limit of attenuation to be displayed by colormap
    param fig: Figure instance created from plt.subplots() call
    param ax: Axes instance created from plt.subplots() call
    param fontsize: fontsize of colorbar title
    param cbar_ax: Where to place the attenuation plot colorbar on the MatPlotLib Figure in refrence to the Axes this plot is drawn on. Defaults to [1,1,1,1]
    param lowerlim: lower limit of attenuation to be displayed by colormap

    return: a colorbar instance for this plot
    """

    x=o.grid.coords[:,0].reshape([o.grid.nShells, o.grid.nCellsPerShell[0]])
    y=o.grid.coords[:,1].reshape([o.grid.nShells, o.grid.nCellsPerShell[0]])

    T = o.T.formatted_data[:,:,0]
    T = T * scaleT + T0
    cmap = sns.color_palette("inferno", as_cmap = True)


    conjtourplot = ax.contourf(x, y, T, np.linspace(lowerlim, upperlim,256), cmap = cmap, extend="both")
    ticksstep = 40
    cbarticks = np.arange(T.min() - (T.min()%ticksstep), T.max() - (T.max()%ticksstep) + ticksstep, ticksstep)
    cbarticks = np.arange(lowerlim, upperlim, ticksstep)
    cbar_ax = fig.add_axes(cbar_ax)
    cb = fig.colorbar(conjtourplot, ticks=cbarticks, orientation = 'horizontal', cax = cbar_ax)
    cb.set_label(label="Temperature [K]", fontsize = fontsize) #22 # 28
    cb.set_ticklabels(ticklabels=cbarticks, fontsize = fontsize-1.5) #20 # 26

    ax.axis('off')

    return cb


def mk_angular_ratio_plot(depthwise_plot):
    """
    mk_angular_ratio_plot takes return from calc_angular_ratio_data and creates a figure with appropriate data

    param depthwise_plot:
    """

    sns.lineplot(data = depthwise_plot, x = 'a_r', y = 'depth', hue = 'Grain Size')
    plt.xlabel('Angular Ratio [deg]', fontsize = 12)
    plt.ylabel('Relative Pen. Depth [%]', fontsize = 12)
    plt.title("Low Loss")
    plt.grid()
    return


def transform_T_to_table(s, o, caseID, T0, scaleT, scaleD, scaleC):
    """
    transform_T_to_table transforms T field from Output class instance of a GAIA simulation and returns the output in a tablular format

    param s: Simulation class instance of specified GAIA simulaiton
    param o: Output class instance of specific time series slice from Simulation class instance
    param caseID: ID(as a string) of the simulation to be loaded
    param T0: Temperature at surface of planet
    param scaleT: value used to redimensionalize the GAIA temperature field
    param scaleD: value used to redimensionalize the GAIA cooridnate space
    param scaleC: if Output class instance has the 'C' field, that redimentionalize the GAIA C field
    return:
    """

    Tprof = o.T.getProfile()

    # data strucute
    #               ["# Column 1: x-coordinate in km \n",
    #                "# Column 2: y-coordinate in km \n",
    #                "# Column 3: z-coordinate in km \n",
    #                "# Column 4: Temperature in K \n",
    #                "# Column 5: Salt concentration in wt% \n"]

    table_list = []
    for i in range(len(o.T.data)):
 
        Tscaled = o.T.data[i]*scaleT + T0
        Xscaled = Tscaled*0.0
        if hasattr(o, 'C'):
            Xscaled = o.C.data[i]*scaleC/920*100*1.5
        x_coord = s.grid.coords[i][0] * scaleD
        y_coord = s.grid.coords[i][1] * scaleD
        z_coord = s.grid.coords[i][2] * scaleD

        rad = (x_coord**2 + y_coord**2 + z_coord**2)**(1/2)

        if(rad > Tprof[-1,0]*scaleD):
            x_coord = x_coord * Tprof[-1,0]*scaleD / rad
            y_coord = y_coord * Tprof[-1,0]*scaleD / rad
            z_coord = z_coord * Tprof[-1,0]*scaleD / rad

        if(rad < Tprof[0,0]*scaleD):
            x_coord = x_coord * Tprof[0,0]*scaleD / rad
            y_coord = y_coord * Tprof[0,0]*scaleD / rad
            z_coord = z_coord * Tprof[0,0]*scaleD / rad

        row = [x_coord, y_coord, z_coord, Tscaled[0], Xscaled[0]]
        table_list.append(row)





    return np.array(table_list)